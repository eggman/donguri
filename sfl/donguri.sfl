declare shift32 {
	input		in<32>;
	input		count<5>;
	output		out<32>;
	output		co;

	instrin		lsl, lsr, asr, por, prx;

	instr_arg	lsl(in, count);
	instr_arg	lsr(in, count);
	instr_arg	asr(in, count);
	instr_arg	por(in, count);
}

declare alu32 {
	input		in1<32>;
	input		in2<32>;
	input		ci;
	output		out<32>;

	instrout	s, v, z, c;
	instrin		do_and, eor, sub, rsb, add, adc, sbc, rsc, tst, teq, cmp, cmn, orr, mov, bic, mvn;

	instr_arg   do_and(in1, in2);
	instr_arg	eor(in1, in2);
	instr_arg	sub(in1, in2);
	instr_arg	rsb(in1, in2);
	instr_arg	add(in1, in2);
	instr_arg	adc(in1, in2, ci);
	instr_arg	sbc(in1, in2, ci);
	instr_arg	rsc(in1, in2, ci);
	instr_arg	tst(in1, in2);
	instr_arg	teq(in1, in2);
	instr_arg	cmp(in1, in2);
	instr_arg	cmn(in1, in2);
	instr_arg	orr(in1, in2);
	instr_arg	mov(in2);
	instr_arg	bic(in1, in2);
	instr_arg	mvn(in1, in2);
}

module alu32 {
	input		in1<32>;
	input		in2<32>;
	input		ci;
	output		out<32>;

	instrout	s, v, z, c;
	instrin		do_and, eor, sub, rsb, add, adc, sbc, rsc, tst, teq, cmp, cmn, orr, mov, bic, mvn;
}

module donguri {
	input	cpu_en;
	input	cpu_restart;
//	input	ram_abort;
//	input	ram_rdata<26>;
	input	rom_abort;
	input	rom_data<32>;

//	output	ram_addr<26>;
//	output	ram_cen;
//	output	ram_flag<4>;
//	output	ram_wdata<32>;
//	output	ram_wen;
	output	rom_addr<26>;
//	output	rom_en;

	instrin	fiq, irq;
	instrin start;
	instrout rd;

	instrself read;

	/* for dedode */
	instrself cEQ, cNE, cCS, cCC, cMI, cPL, cVS, cVC, cHI, cLS, cGE, cLT, cGT, cLE, cAL, cNV;
	instrself oDP0, oDP1, oDP2, oMUL, oLDR0, oLDR1, oLDM, oB, oSWI, oUND;
	instrself opAND, opEOR, opSUB, opRSB, opADD, opADC, opSBC, opRSC, opTST, opTEQ, opCMP, opCMN, opORR, opMOV, opBIC, opMVN;

	/* for execute */
	instrself decop;

	sel dbi<32>;			/* instruction bus */
	sel ABin<26>;			/* Addrss Bus */
	sel	Rn<32>, Rd<32>;		/* output of Register bank */
	sel Abus<32>;
	sel Bbus<32>;
	sel ALUbus<32>;

	sel psr_mode<2>;

	reg_wr	r0<32>,r1<32>,r2<32>,r3<32>,r4<32>,r5<32>,r6<32>,r7<32>,r8<32>,r9<32>,r10<32>,r11<32>,r12<32>,r13<32>,r14<32>;
	reg_wr	psr_n, psr_z, psr_c, psr_v, psr_i, psr_f;
	reg_wr	pc<26>;
	reg		opc<32>;			/* instrunction at exec stage*/

	alu32	alu;

	stage_name ift{		/* instruction fetch */
		task run();
		task do_fiq();
		task do_irq();
		task res();
	}

	stage_name decode{		/* instruction decode */
		task dec();
	}

	stage_name exec{		/* execute */
		task exe();
	}

/* Common operatins for every stages */
	par {
		any {
			opc<15:12>==0x0: Rd = r0;
			opc<15:12>==0x1: Rd = r1;
			opc<15:12>==0x2: Rd = r2;
			opc<15:12>==0x3: Rd = r3;
			opc<15:12>==0x4: Rd = r4;
			opc<15:12>==0x5: Rd = r5;
			opc<15:12>==0x6: Rd = r6;
			opc<15:12>==0x7: Rd = r7;
			opc<15:12>==0x8: Rd = r8;
			opc<15:12>==0x9: Rd = r9;
			opc<15:12>==0xa: Rd = r10;
			opc<15:12>==0xb: Rd = r11;
			opc<15:12>==0xc: Rd = r12;
			opc<15:12>==0xd: Rd = r13;
			opc<15:12>==0xe: Rd = r14;
//			opc<15:12>==0xf: Rd = r15+0x00000004;
		}

		any {
			opc<19:16>==0x0: Rn = r0;
			opc<19:16>==0x1: Rn = r1;
			opc<19:16>==0x2: Rn = r2;
			opc<19:16>==0x3: Rn = r3;
			opc<19:16>==0x4: Rn = r4;
			opc<19:16>==0x5: Rn = r5;
			opc<19:16>==0x6: Rn = r6;
			opc<19:16>==0x7: Rn = r7;
			opc<19:16>==0x8: Rn = r8;
			opc<19:16>==0x9: Rn = r9;
			opc<19:16>==0xa: Rn = r10;
			opc<19:16>==0xb: Rn = r11;
			opc<19:16>==0xc: Rn = r12;
			opc<19:16>==0xd: Rn = r13;
			opc<19:16>==0xe: Rn = r14;
//			opc<19:16>==0xf: Rn = r15+0x00000004;
		}
	}

	instruct read par { dbi = rom_data; rd();}
	instruct fiq  generate ift.do_fiq();
	instruct irq  generate ift.do_irq();

//	instruct decode_d par {
//		any {
//			oMUL | oB:				opADD();
//			(oDP0 | oDP1 | oDP2)&((opc<24:21>==0b0010)|(opc<24:21>==0b0101)|(opc<24:21>==0b1011)): 	opADD();
//			else: if(opc<23>)		opADD();
//		}
//	}

	instruct start generate ift.run();

	instruct decop par {
		any {
			opc<27:25>==0b000 & ( opc<24:23>!=0b10 | opc<20> ) & ^opc<4>:   		oDP0(); 	// Data Proccessing shift Im
			opc<27:25>==0b000 & ( opc<24:23>!=0b10 | opc<20> ) &  opc<4> & ^opc<7>:	oDP1();		// Data Proccessing shift Rs
			opc<27:25>==0b001 & ( opc<24:23>!=0b10 | opc<20> ): 					oDP2();		// Data Proccessing Im
			opc<27:22>==0b000000:	oMUL();						// Muliply
			opc<27:25>==0b010:  	oLDR0();					// Single data transfer
			opc<27:25>==0b011:  	oLDR1();					// Single data transfer Im
			opc<27:25>==0b100:  	oLDM();						// Block data ransfer
			opc<27:25>==0b101:  	oB();						// Branch and branch wih link
			opc<27:24>==0b1111:  	oSWI();						// Sofwave ineterrupt
			(opc<27:24>==0b0001 & opc<7>==0b1 & opc<4>==0b1 ) |
			(opc<27:25>==0b011	& opc<4>==0b1 )	:  	oUND();		// Undefined instructions
		}

		any {
			opc<27:26>==0b00: any {
				opc<24:21>==0x0: opAND();
				opc<24:21>==0x1: opEOR();
				opc<24:21>==0x2: opSUB();
				opc<24:21>==0x3: opRSB();
				opc<24:21>==0x4: opADD();
				opc<24:21>==0x5: opADC();
				opc<24:21>==0x6: opSBC();
				opc<24:21>==0x7: opRSC();
				opc<24:21>==0x8: opTST();
				opc<24:21>==0x9: opTEQ();
				opc<24:21>==0xa: opCMP();
				opc<24:21>==0xb: opCMN();
				opc<24:21>==0xc: opORR();
				opc<24:21>==0xd: opMOV();
				opc<24:21>==0xe: opBIC();
				opc<24:21>==0xf: opMVN();
			}
		}

		any {
			opc<31:28>==0x0:  cEQ();
			opc<31:28>==0x1:  cNE();
			opc<31:28>==0x2:  cCS();
			opc<31:28>==0x3:  cCC();
			opc<31:28>==0x4:  cMI();
			opc<31:28>==0x5:  cPL();
			opc<31:28>==0x6:  cVS();
			opc<31:28>==0x7:  cVC();
			opc<31:28>==0x8:  cHI();
			opc<31:28>==0x9:  cLS();
			opc<31:28>==0xa:  cGE();
			opc<31:28>==0xb:  cLT();
			opc<31:28>==0xc:  cGT();
			opc<31:28>==0xd:  cLE();
			opc<31:28>==0xe:  cAL();
			opc<31:28>==0xf:  cNV();
		}
	}

	instruct opAND par {
		alu.do_and(Abus, Bbus);
		ALUbus = alu.out;
//		if(opc<20>==1) psr_z := alu.z;
	}
	instruct opEOR par {
		alu.eor(Abus, Bbus);
		ALUbus = alu.out;
		psr_z := alu.z;
	}
	instruct opSUB par {
		alu.sub(Abus, Bbus);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opRSB par {
		alu.rsb(Abus, Bbus);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opADD par {
		alu.add(Abus, Bbus);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opADC par {
		alu.adc(Abus, Bbus, psr_c);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opSBC par {
		alu.sbc(Abus, Bbus, psr_c);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opRSC par {
		alu.rsc(Abus, Bbus, psr_c);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opTST par {
		alu.tst(Abus, Bbus);
		psr_z := alu.z;
	}
	instruct opTEQ par {
		alu.teq(Abus, Bbus);
		psr_z := alu.z;
	}
	instruct opCMP par {
		alu.cmp(Abus, Bbus);
		psr_z := alu.z;
	}
	instruct opCMN par {
		alu.cmn(Abus, Bbus);
		psr_z := alu.z;
	}
	instruct opORR par {
		alu.orr(Abus, Bbus);
		psr_z := alu.z;
	}
	instruct opMOV par {
		alu.mov(Bbus);
		psr_z := alu.z;
	}
	instruct opBIC par {
		alu.bic(Abus, Bbus);
		psr_z := alu.z;
	}
	instruct opMVN par {
		alu.mvn(Abus, Bbus);
		psr_z := alu.z;
	}


/* Fetch Stage */
/*  - set address of instruction */
	stage ift {
		/* fetch instruction ->OP */
		any {
			 ^ift.do_fiq & ^ift.do_irq  : par {
				rom_addr = pc;
				pc := pc + 0b00||0x000004;
				relay decode.dec();
			}
			ift.res: par {
				rom_addr = 0b00||0x000000;
				relay decode.dec();
			}
			ift.do_fiq: par {
				rom_addr = 0b00||0x00001c;
				relay decode.dec();
			}
			ift.do_irq: par {
				rom_addr = 0b00||0x000018;
				relay decode.dec();
			}
		}

	}

/* Decode Stage */
	stage decode {
		par {
			read();
			opc := dbi;
			relay exec.exe();
		}
	}

/* Execute Stage */
	stage exec {
		par {
			decop();
		}
		relay ift.run();
	}
}
