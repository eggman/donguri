declare shift32 {
	input		in<32>;
	input		count<5>;
//	input		ci;
	input		dir<2>;		//lsl, lsr, asr, por, prx;
	output		out<32>;
//	output		co;

	instrin		none, immrot, simm, sreg;

	instr_arg	none(in);
	instr_arg	immrot(in, count);
	instr_arg	simm(in, count, dir);
	instr_arg	sreg(in, count, dir);
}

declare alu32 {
	input		in1<32>;
	input		in2<32>;
	input		ci;
	output		out<32>;
//	output		cout;

	instrout	s, v, z, c;
	instrin		do_and, eor, sub, rsb, add, adc, sbc, rsc, tst, teq, cmp, cmn, orr, mov, bic, mvn;

	instr_arg   do_and(in1, in2);
	instr_arg	eor(in1, in2);
	instr_arg	sub(in1, in2);
	instr_arg	rsb(in1, in2);
	instr_arg	add(in1, in2);
	instr_arg	adc(in1, in2, ci);
	instr_arg	sbc(in1, in2, ci);
	instr_arg	rsc(in1, in2, ci);
	instr_arg	tst(in1, in2);
	instr_arg	teq(in1, in2);
	instr_arg	cmp(in1, in2);
	instr_arg	cmn(in1, in2);
	instr_arg	orr(in1, in2);
	instr_arg	mov(in2);
	instr_arg	bic(in1, in2);
	instr_arg	mvn(in1, in2);
}

declare inc26 {
	input       in<26> ;
	output      out<26> ;
	instrin     do ;
	instr_arg	do(in);
}

module shift32 {
	input		in<32>;
	input		count<5>;
//	input		ci;
	input		dir<2>;		//lsl, lsr, asr, por, prx;
	output		out<32>;
//	output		co;

	instrin		none, immrot, simm, sreg;

	instruct	none out = in;
	instruct	immrot {
		out = in;
	}
	instruct	simm {
		out = in;
	}
	instruct	sreg {
		out = in;
	}
}


module alu32 {
	input		in1<32>;
	input		in2<32>;
	input		ci;
	output		out<32>;

	instrout	s, v, z, c;
	instrin		do_and, eor, sub, rsb, add, adc, sbc, rsc, tst, teq, cmp, cmn, orr, mov, bic, mvn;

	instruct	mov par{
		out = in2;
		if(in2==0x00000000)	z();
		c();
		s();
		v();
	}
}

circuit inc26 {
	input       in<26> ;
	output      out<26> ;
	instrin     do ;
	instruct 	do out = in + (0b00||0x000004);
}



module donguri {
	input	cpu_en;
	input	cpu_restart;
//	input	ram_abort;
//	input	ram_rdata<26>;
	input	rom_abort;
	input	rom_data<32>;

//	output	ram_addr<26>;
//	output	ram_cen;
//	output	ram_flag<4>;
//	output	ram_wdata<32>;
//	output	ram_wen;
	output	rom_addr<26>;
//	output	rom_en;

	instrin	fiq, irq;
	instrin start;
	instrout rd;

	instrself read;

	/* for dedode */
	instrself cEQ, cNE, cCS, cCC, cMI, cPL, cVS, cVC, cHI, cLS, cGE, cLT, cGT, cLE, cAL, cNV;
	instrself oDP0, oDP1, oDP2, oMUL, oLDR0, oLDR1, oLDM, oB, oSWI, oUND;
	instrself opAND, opEOR, opSUB, opRSB, opADD, opADC, opSBC, opRSC, opTST, opTEQ, opCMP, opCMN, opORR, opMOV, opBIC, opMVN;

	/* for execute */
	instrself decop;

	sel dbi<32>;			/* instruction bus */
	sel ABin<26>;			/* Addrss Bus */
	sel	Rd<32>;				/* destination of Register bank */
	sel	Rn<32>, Rm<32>;		/* output of Register bank */
	sel	Rs<32>;				/* output of Register bank */
	sel Abus<32>;
	sel Bbus<32>;
	sel OP1bus<32>;
	sel OP2bus<32>;
	sel ALUbus<32>;
	sel PCbus<26>;
	sel INCbus<26>;
	sel ADRbus<26>;

	sel psr_mode<2>;

	reg_wr	r0<32>,r1<32>,r2<32>,r3<32>,r4<32>,r5<32>,r6<32>,r7<32>,r8<32>,r9<32>,r10<32>,r11<32>,r12<32>,r13<32>,r14<32>;
	reg_wr	psr_n, psr_z, psr_c, psr_v, psr_i, psr_f;
	reg_wr	pc<26>;
	reg		opc<32>;		/* instrunction at exec stage*/
	reg_wr	adr<26>;

	alu32	alu;
	shift32	shift;
	inc26	inc;

	stage_name ift{			/* instruction fetch */
		task run();
		task do_fiq();
		task do_irq();
		task res();
	}

	stage_name decode{		/* instruction decode */
		task dec();
	}

	stage_name exec{		/* execute */
		task exe();
	}

/* Common operatins for every stages */
	par {
		Rd = ALUbus;
		any {
			opc<15:12>==0x0: r0  := Rd;
			opc<15:12>==0x1: r1  := Rd;
			opc<15:12>==0x2: r2  := Rd;
			opc<15:12>==0x3: r3  := Rd;
			opc<15:12>==0x4: r4  := Rd;
			opc<15:12>==0x5: r5  := Rd;
			opc<15:12>==0x6: r6  := Rd;
			opc<15:12>==0x7: r7  := Rd;
			opc<15:12>==0x8: r8  := Rd;
			opc<15:12>==0x9: r9  := Rd;
			opc<15:12>==0xa: r10 := Rd;
			opc<15:12>==0xb: r11 := Rd;
			opc<15:12>==0xc: r12 := Rd;
			opc<15:12>==0xd: r13 := Rd;
			opc<15:12>==0xe: r14 := Rd;
//			opc<15:12>==0xf: pc  := Rd;
		}

		any {
			opc<19:16>==0x0: Rn = r0;
			opc<19:16>==0x1: Rn = r1;
			opc<19:16>==0x2: Rn = r2;
			opc<19:16>==0x3: Rn = r3;
			opc<19:16>==0x4: Rn = r4;
			opc<19:16>==0x5: Rn = r5;
			opc<19:16>==0x6: Rn = r6;
			opc<19:16>==0x7: Rn = r7;
			opc<19:16>==0x8: Rn = r8;
			opc<19:16>==0x9: Rn = r9;
			opc<19:16>==0xa: Rn = r10;
			opc<19:16>==0xb: Rn = r11;
			opc<19:16>==0xc: Rn = r12;
			opc<19:16>==0xd: Rn = r13;
			opc<19:16>==0xe: Rn = r14;
			opc<19:16>==0xf: Rn = 0b000000||pc;
		}

		any {
			opc<3:0>==0x0: Rm = r0;
			opc<3:0>==0x1: Rm = r1;
			opc<3:0>==0x2: Rm = r2;
			opc<3:0>==0x3: Rm = r3;
			opc<3:0>==0x4: Rm = r4;
			opc<3:0>==0x5: Rm = r5;
			opc<3:0>==0x6: Rm = r6;
			opc<3:0>==0x7: Rm = r7;
			opc<3:0>==0x8: Rm = r8;
			opc<3:0>==0x9: Rm = r9;
			opc<3:0>==0xa: Rm = r10;
			opc<3:0>==0xb: Rm = r11;
			opc<3:0>==0xc: Rm = r12;
			opc<3:0>==0xd: Rm = r13;
			opc<3:0>==0xe: Rm = r14;
			opc<3:0>==0xf: Rm = psr_n||psr_z||psr_c||psr_v||psr_i||psr_f||pc;
		}


		INCbus = inc.do(ADRbus).out ;		//Incrementer
		rom_addr = adr;
	}

//	instruct read par { dbi = rom_data; rd();}
	instruct fiq  generate ift.do_fiq();
	instruct irq  generate ift.do_irq();

//	instruct decode_d par {
//		any {
//			oMUL | oB:				opADD();
//			(oDP0 | oDP1 | oDP2)&((opc<24:21>==0b0010)|(opc<24:21>==0b0101)|(opc<24:21>==0b1011)): 	opADD();
//			else: if(opc<23>)		opADD();
//		}
//	}

	instruct start generate ift.run();

	instruct decop par {
		any {
			opc<27:25>==0b000 & ( opc<24:23>!=0b10 | opc<20> ) & ^opc<4>:   		oDP0(); 	/* Data Proccessing shift Im */
			opc<27:25>==0b000 & ( opc<24:23>!=0b10 | opc<20> ) &  opc<4> & ^opc<7>:	oDP1();		/* Data Proccessing shift Rs */
			opc<27:25>==0b001 & ( opc<24:23>!=0b10 | opc<20> ): 					oDP2();		/* Data Proccessing Im */
			opc<27:22>==0b000000:	oMUL();						/* Muliply */
			opc<27:25>==0b010:  	oLDR0();					/* Single data transfer */
			opc<27:25>==0b011:  	oLDR1();					/* Single data transfer Im */
			opc<27:25>==0b100:  	oLDM();						/* Block data ransfer */
			opc<27:25>==0b101:  	oB();						/* Branch and branch wih link */
			opc<27:24>==0b1111:  	oSWI();						/* Sofwave ineterrupt */
			(opc<27:24>==0b0001 & opc<7>==0b1 & opc<4>==0b1 ) |
			(opc<27:25>==0b011	& opc<4>==0b1 )	:  	oUND();		/* Undefined instructions */
		}

		// for ALU
		any {
			opc<27:26>==0b00: any {
				opc<24:21>==0x0: opAND();
				opc<24:21>==0x1: opEOR();
				opc<24:21>==0x2: opSUB();
				opc<24:21>==0x3: opRSB();
				opc<24:21>==0x4: opADD();
				opc<24:21>==0x5: opADC();
				opc<24:21>==0x6: opSBC();
				opc<24:21>==0x7: opRSC();
				opc<24:21>==0x8: opTST();
				opc<24:21>==0x9: opTEQ();
				opc<24:21>==0xa: opCMP();
				opc<24:21>==0xb: opCMN();
				opc<24:21>==0xc: opORR();
				opc<24:21>==0xd: opMOV();
				opc<24:21>==0xe: opBIC();
				opc<24:21>==0xf: opMVN();
			}
		}

		any {
			opc<31:28>==0x0:  cEQ();
			opc<31:28>==0x1:  cNE();
			opc<31:28>==0x2:  cCS();
			opc<31:28>==0x3:  cCC();
			opc<31:28>==0x4:  cMI();
			opc<31:28>==0x5:  cPL();
			opc<31:28>==0x6:  cVS();
			opc<31:28>==0x7:  cVC();
			opc<31:28>==0x8:  cHI();
			opc<31:28>==0x9:  cLS();
			opc<31:28>==0xa:  cGE();
			opc<31:28>==0xb:  cLT();
			opc<31:28>==0xc:  cGT();
			opc<31:28>==0xd:  cLE();
			opc<31:28>==0xe:  cAL();
			opc<31:28>==0xf:  cNV();
		}
	}

	instruct oDP0 par {
		Bbus = Rm;
		OP2bus = shift.simm(Bbus, opc<11:7>, opc<6:5>).out;
	}

	instruct oDP1 par {
		Bbus = Rm;
		OP2bus = shift.sreg(Bbus, Rs<4:0>, opc<6:5>).out;
	}

	instruct oDP2 par {
		Bbus = 0x000000||opc<7:0>;
		OP2bus = shift.immrot(Bbus, 0b0||opc<11:8>).out;
	}

	instruct oB par {
		Bbus = 0x00||opc<23:0>;
		OP2bus = shift.simm(Bbus, 0b0||0x2, 0b11).out;
	}

	instruct opAND par {
		alu.do_and(Abus, OP2bus);
		ALUbus = alu.out;
//		if(opc<20>==1) psr_z := alu.z;
	}
	instruct opEOR par {
		alu.eor(Abus, OP2bus);
		ALUbus = alu.out;
		psr_z := alu.z;
	}
	instruct opSUB par {
		alu.sub(Abus, OP2bus);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opRSB par {
		alu.rsb(Abus, OP2bus);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opADD par {
		alu.add(Abus, OP2bus);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opADC par {
		alu.adc(Abus, OP2bus, psr_c);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opSBC par {
		alu.sbc(Abus, OP2bus, psr_c);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opRSC par {
		alu.rsc(Abus, OP2bus, psr_c);
		ALUbus = alu.out;
		psr_z := alu.z; psr_c := alu.c; psr_v := alu.v;
	}
	instruct opTST par {
		alu.tst(Abus, OP2bus);
		psr_z := alu.z;
	}
	instruct opTEQ par {
		alu.teq(Abus, OP2bus);
		psr_z := alu.z;
	}
	instruct opCMP par {
		alu.cmp(Abus, OP2bus);
		psr_z := alu.z;
	}
	instruct opCMN par {
		alu.cmn(Abus, OP2bus);
		psr_z := alu.z;
	}
	instruct opORR par {
		alu.orr(Abus, OP2bus);
		psr_z := alu.z;
	}
	instruct opMOV par {
		alu.mov(OP2bus);
		ALUbus = alu.out;
		psr_z := alu.z;
	}
	instruct opBIC par {
		alu.bic(Abus, OP2bus);
		psr_z := alu.z;
	}
	instruct opMVN par {
		alu.mvn(Abus, OP2bus);
		psr_z := alu.z;
	}


/* Fetch Stage */
/*  - set address of instruction */
	stage ift {
		/* fetch instruction ->OP */
		any {
			 ^ift.do_fiq & ^ift.do_irq  : par {
				ADRbus = INCbus;
			}
			ift.res: par {
				ADRbus = 0b00||0x000000;
			}
			ift.do_fiq: par {
				ADRbus = 0b00||0x00001c;
			}
			ift.do_irq: par {
				ADRbus = 0b00||0x000018;
			}
		}
		adr := ADRbus;
		relay decode.dec();
	}

/* Decode Stage */
	stage decode {
		par {
//			read();
			opc := rom_data;
			relay exec.exe();
		}
	}

/* Execute Stage */
	stage exec {
		par {
			decop();
		}
		relay ift.run();
	}
}
